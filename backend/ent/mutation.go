// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/theuo/app/ent/bill"
	"github.com/theuo/app/ent/billstatus"
	"github.com/theuo/app/ent/payment"
	"github.com/theuo/app/ent/paymentstatus"
	"github.com/theuo/app/ent/paytype"
	"github.com/theuo/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBill          = "Bill"
	TypeBillStatus    = "BillStatus"
	TypePayType       = "PayType"
	TypePayment       = "Payment"
	TypePaymentStatus = "PaymentStatus"
	TypeUser          = "User"
)

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Amount           *int
	add_Amount        *int
	clearedFields     map[string]struct{}
	billstatus        *int
	clearedbillstatus bool
	payments          *int
	clearedpayments   bool
	resident          *int
	clearedresident   bool
	done              bool
	oldValue          func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the Amount field.
func (m *BillMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the Amount value in the mutation.
func (m *BillMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old Amount value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to Amount.
func (m *BillMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the Amount field in this mutation.
func (m *BillMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "Amount" field.
func (m *BillMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// SetBillstatusID sets the billstatus edge to BillStatus by id.
func (m *BillMutation) SetBillstatusID(id int) {
	m.billstatus = &id
}

// ClearBillstatus clears the billstatus edge to BillStatus.
func (m *BillMutation) ClearBillstatus() {
	m.clearedbillstatus = true
}

// BillstatusCleared returns if the edge billstatus was cleared.
func (m *BillMutation) BillstatusCleared() bool {
	return m.clearedbillstatus
}

// BillstatusID returns the billstatus id in the mutation.
func (m *BillMutation) BillstatusID() (id int, exists bool) {
	if m.billstatus != nil {
		return *m.billstatus, true
	}
	return
}

// BillstatusIDs returns the billstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillstatusID instead. It exists only for internal usage by the builders.
func (m *BillMutation) BillstatusIDs() (ids []int) {
	if id := m.billstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillstatus reset all changes of the "billstatus" edge.
func (m *BillMutation) ResetBillstatus() {
	m.billstatus = nil
	m.clearedbillstatus = false
}

// SetPaymentsID sets the payments edge to Payment by id.
func (m *BillMutation) SetPaymentsID(id int) {
	m.payments = &id
}

// ClearPayments clears the payments edge to Payment.
func (m *BillMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared returns if the edge payments was cleared.
func (m *BillMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// PaymentsID returns the payments id in the mutation.
func (m *BillMutation) PaymentsID() (id int, exists bool) {
	if m.payments != nil {
		return *m.payments, true
	}
	return
}

// PaymentsIDs returns the payments ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymentsID instead. It exists only for internal usage by the builders.
func (m *BillMutation) PaymentsIDs() (ids []int) {
	if id := m.payments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayments reset all changes of the "payments" edge.
func (m *BillMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
}

// SetResidentID sets the resident edge to User by id.
func (m *BillMutation) SetResidentID(id int) {
	m.resident = &id
}

// ClearResident clears the resident edge to User.
func (m *BillMutation) ClearResident() {
	m.clearedresident = true
}

// ResidentCleared returns if the edge resident was cleared.
func (m *BillMutation) ResidentCleared() bool {
	return m.clearedresident
}

// ResidentID returns the resident id in the mutation.
func (m *BillMutation) ResidentID() (id int, exists bool) {
	if m.resident != nil {
		return *m.resident, true
	}
	return
}

// ResidentIDs returns the resident ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResidentID instead. It exists only for internal usage by the builders.
func (m *BillMutation) ResidentIDs() (ids []int) {
	if id := m.resident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResident reset all changes of the "resident" edge.
func (m *BillMutation) ResetResident() {
	m.resident = nil
	m.clearedresident = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.billstatus != nil {
		edges = append(edges, bill.EdgeBillstatus)
	}
	if m.payments != nil {
		edges = append(edges, bill.EdgePayments)
	}
	if m.resident != nil {
		edges = append(edges, bill.EdgeResident)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeBillstatus:
		if id := m.billstatus; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgePayments:
		if id := m.payments; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeResident:
		if id := m.resident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbillstatus {
		edges = append(edges, bill.EdgeBillstatus)
	}
	if m.clearedpayments {
		edges = append(edges, bill.EdgePayments)
	}
	if m.clearedresident {
		edges = append(edges, bill.EdgeResident)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeBillstatus:
		return m.clearedbillstatus
	case bill.EdgePayments:
		return m.clearedpayments
	case bill.EdgeResident:
		return m.clearedresident
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeBillstatus:
		m.ClearBillstatus()
		return nil
	case bill.EdgePayments:
		m.ClearPayments()
		return nil
	case bill.EdgeResident:
		m.ClearResident()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeBillstatus:
		m.ResetBillstatus()
		return nil
	case bill.EdgePayments:
		m.ResetPayments()
		return nil
	case bill.EdgeResident:
		m.ResetResident()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// BillStatusMutation represents an operation that mutate the BillStatusSlice
// nodes in the graph.
type BillStatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_BillStatus   *string
	clearedFields map[string]struct{}
	bills         map[int]struct{}
	removedbills  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*BillStatus, error)
}

var _ ent.Mutation = (*BillStatusMutation)(nil)

// billstatusOption allows to manage the mutation configuration using functional options.
type billstatusOption func(*BillStatusMutation)

// newBillStatusMutation creates new mutation for $n.Name.
func newBillStatusMutation(c config, op Op, opts ...billstatusOption) *BillStatusMutation {
	m := &BillStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeBillStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillStatusID sets the id field of the mutation.
func withBillStatusID(id int) billstatusOption {
	return func(m *BillStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *BillStatus
		)
		m.oldValue = func(ctx context.Context) (*BillStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillStatus sets the old BillStatus of the mutation.
func withBillStatus(node *BillStatus) billstatusOption {
	return func(m *BillStatusMutation) {
		m.oldValue = func(context.Context) (*BillStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBillStatus sets the BillStatus field.
func (m *BillStatusMutation) SetBillStatus(s string) {
	m._BillStatus = &s
}

// BillStatus returns the BillStatus value in the mutation.
func (m *BillStatusMutation) BillStatus() (r string, exists bool) {
	v := m._BillStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldBillStatus returns the old BillStatus value of the BillStatus.
// If the BillStatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillStatusMutation) OldBillStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillStatus: %w", err)
	}
	return oldValue.BillStatus, nil
}

// ResetBillStatus reset all changes of the "BillStatus" field.
func (m *BillStatusMutation) ResetBillStatus() {
	m._BillStatus = nil
}

// AddBillIDs adds the bills edge to Bill by ids.
func (m *BillStatusMutation) AddBillIDs(ids ...int) {
	if m.bills == nil {
		m.bills = make(map[int]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bills edge to Bill by ids.
func (m *BillStatusMutation) RemoveBillIDs(ids ...int) {
	if m.removedbills == nil {
		m.removedbills = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed ids of bills.
func (m *BillStatusMutation) RemovedBillsIDs() (ids []int) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the bills ids in the mutation.
func (m *BillStatusMutation) BillsIDs() (ids []int) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills reset all changes of the "bills" edge.
func (m *BillStatusMutation) ResetBills() {
	m.bills = nil
	m.removedbills = nil
}

// Op returns the operation name.
func (m *BillStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BillStatus).
func (m *BillStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillStatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._BillStatus != nil {
		fields = append(fields, billstatus.FieldBillStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billstatus.FieldBillStatus:
		return m.BillStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billstatus.FieldBillStatus:
		return m.OldBillStatus(ctx)
	}
	return nil, fmt.Errorf("unknown BillStatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billstatus.FieldBillStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BillStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillStatusMutation) ResetField(name string) error {
	switch name {
	case billstatus.FieldBillStatus:
		m.ResetBillStatus()
		return nil
	}
	return fmt.Errorf("unknown BillStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bills != nil {
		edges = append(edges, billstatus.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billstatus.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbills != nil {
		edges = append(edges, billstatus.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billstatus.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillStatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BillStatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillStatusMutation) ResetEdge(name string) error {
	switch name {
	case billstatus.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown BillStatus edge %s", name)
}

// PayTypeMutation represents an operation that mutate the PayTypes
// nodes in the graph.
type PayTypeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_TypeInfo       *string
	clearedFields   map[string]struct{}
	payments        map[int]struct{}
	removedpayments map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*PayType, error)
}

var _ ent.Mutation = (*PayTypeMutation)(nil)

// paytypeOption allows to manage the mutation configuration using functional options.
type paytypeOption func(*PayTypeMutation)

// newPayTypeMutation creates new mutation for $n.Name.
func newPayTypeMutation(c config, op Op, opts ...paytypeOption) *PayTypeMutation {
	m := &PayTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePayType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayTypeID sets the id field of the mutation.
func withPayTypeID(id int) paytypeOption {
	return func(m *PayTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PayType
		)
		m.oldValue = func(ctx context.Context) (*PayType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PayType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayType sets the old PayType of the mutation.
func withPayType(node *PayType) paytypeOption {
	return func(m *PayTypeMutation) {
		m.oldValue = func(context.Context) (*PayType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PayTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypeInfo sets the TypeInfo field.
func (m *PayTypeMutation) SetTypeInfo(s string) {
	m._TypeInfo = &s
}

// TypeInfo returns the TypeInfo value in the mutation.
func (m *PayTypeMutation) TypeInfo() (r string, exists bool) {
	v := m._TypeInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeInfo returns the old TypeInfo value of the PayType.
// If the PayType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PayTypeMutation) OldTypeInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeInfo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeInfo: %w", err)
	}
	return oldValue.TypeInfo, nil
}

// ResetTypeInfo reset all changes of the "TypeInfo" field.
func (m *PayTypeMutation) ResetTypeInfo() {
	m._TypeInfo = nil
}

// AddPaymentIDs adds the payments edge to Payment by ids.
func (m *PayTypeMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payments edge to Payment by ids.
func (m *PayTypeMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed ids of payments.
func (m *PayTypeMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the payments ids in the mutation.
func (m *PayTypeMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments reset all changes of the "payments" edge.
func (m *PayTypeMutation) ResetPayments() {
	m.payments = nil
	m.removedpayments = nil
}

// Op returns the operation name.
func (m *PayTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PayType).
func (m *PayTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PayTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TypeInfo != nil {
		fields = append(fields, paytype.FieldTypeInfo)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PayTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paytype.FieldTypeInfo:
		return m.TypeInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PayTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paytype.FieldTypeInfo:
		return m.OldTypeInfo(ctx)
	}
	return nil, fmt.Errorf("unknown PayType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PayTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paytype.FieldTypeInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeInfo(v)
		return nil
	}
	return fmt.Errorf("unknown PayType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PayTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PayTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PayTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PayType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PayTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PayTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PayType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PayTypeMutation) ResetField(name string) error {
	switch name {
	case paytype.FieldTypeInfo:
		m.ResetTypeInfo()
		return nil
	}
	return fmt.Errorf("unknown PayType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PayTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payments != nil {
		edges = append(edges, paytype.EdgePayments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PayTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paytype.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PayTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayments != nil {
		edges = append(edges, paytype.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PayTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paytype.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PayTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PayTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PayTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PayType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PayTypeMutation) ResetEdge(name string) error {
	switch name {
	case paytype.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown PayType edge %s", name)
}

// PaymentMutation represents an operation that mutate the Payments
// nodes in the graph.
type PaymentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_AddDatetime         *time.Time
	clearedFields        map[string]struct{}
	paytype              *int
	clearedpaytype       bool
	paymentstatus        *int
	clearedpaymentstatus bool
	bill                 *int
	clearedbill          bool
	done                 bool
	oldValue             func(context.Context) (*Payment, error)
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows to manage the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for $n.Name.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the id field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddDatetime sets the AddDatetime field.
func (m *PaymentMutation) SetAddDatetime(t time.Time) {
	m._AddDatetime = &t
}

// AddDatetime returns the AddDatetime value in the mutation.
func (m *PaymentMutation) AddDatetime() (r time.Time, exists bool) {
	v := m._AddDatetime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddDatetime returns the old AddDatetime value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldAddDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddDatetime: %w", err)
	}
	return oldValue.AddDatetime, nil
}

// ResetAddDatetime reset all changes of the "AddDatetime" field.
func (m *PaymentMutation) ResetAddDatetime() {
	m._AddDatetime = nil
}

// SetPaytypeID sets the paytype edge to PayType by id.
func (m *PaymentMutation) SetPaytypeID(id int) {
	m.paytype = &id
}

// ClearPaytype clears the paytype edge to PayType.
func (m *PaymentMutation) ClearPaytype() {
	m.clearedpaytype = true
}

// PaytypeCleared returns if the edge paytype was cleared.
func (m *PaymentMutation) PaytypeCleared() bool {
	return m.clearedpaytype
}

// PaytypeID returns the paytype id in the mutation.
func (m *PaymentMutation) PaytypeID() (id int, exists bool) {
	if m.paytype != nil {
		return *m.paytype, true
	}
	return
}

// PaytypeIDs returns the paytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaytypeID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) PaytypeIDs() (ids []int) {
	if id := m.paytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaytype reset all changes of the "paytype" edge.
func (m *PaymentMutation) ResetPaytype() {
	m.paytype = nil
	m.clearedpaytype = false
}

// SetPaymentstatusID sets the paymentstatus edge to PaymentStatus by id.
func (m *PaymentMutation) SetPaymentstatusID(id int) {
	m.paymentstatus = &id
}

// ClearPaymentstatus clears the paymentstatus edge to PaymentStatus.
func (m *PaymentMutation) ClearPaymentstatus() {
	m.clearedpaymentstatus = true
}

// PaymentstatusCleared returns if the edge paymentstatus was cleared.
func (m *PaymentMutation) PaymentstatusCleared() bool {
	return m.clearedpaymentstatus
}

// PaymentstatusID returns the paymentstatus id in the mutation.
func (m *PaymentMutation) PaymentstatusID() (id int, exists bool) {
	if m.paymentstatus != nil {
		return *m.paymentstatus, true
	}
	return
}

// PaymentstatusIDs returns the paymentstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymentstatusID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) PaymentstatusIDs() (ids []int) {
	if id := m.paymentstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentstatus reset all changes of the "paymentstatus" edge.
func (m *PaymentMutation) ResetPaymentstatus() {
	m.paymentstatus = nil
	m.clearedpaymentstatus = false
}

// SetBillID sets the bill edge to Bill by id.
func (m *PaymentMutation) SetBillID(id int) {
	m.bill = &id
}

// ClearBill clears the bill edge to Bill.
func (m *PaymentMutation) ClearBill() {
	m.clearedbill = true
}

// BillCleared returns if the edge bill was cleared.
func (m *PaymentMutation) BillCleared() bool {
	return m.clearedbill
}

// BillID returns the bill id in the mutation.
func (m *PaymentMutation) BillID() (id int, exists bool) {
	if m.bill != nil {
		return *m.bill, true
	}
	return
}

// BillIDs returns the bill ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) BillIDs() (ids []int) {
	if id := m.bill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBill reset all changes of the "bill" edge.
func (m *PaymentMutation) ResetBill() {
	m.bill = nil
	m.clearedbill = false
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._AddDatetime != nil {
		fields = append(fields, payment.FieldAddDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAddDatetime:
		return m.AddDatetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldAddDatetime:
		return m.OldAddDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAddDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldAddDatetime:
		m.ResetAddDatetime()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.paytype != nil {
		edges = append(edges, payment.EdgePaytype)
	}
	if m.paymentstatus != nil {
		edges = append(edges, payment.EdgePaymentstatus)
	}
	if m.bill != nil {
		edges = append(edges, payment.EdgeBill)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePaytype:
		if id := m.paytype; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgePaymentstatus:
		if id := m.paymentstatus; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgeBill:
		if id := m.bill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpaytype {
		edges = append(edges, payment.EdgePaytype)
	}
	if m.clearedpaymentstatus {
		edges = append(edges, payment.EdgePaymentstatus)
	}
	if m.clearedbill {
		edges = append(edges, payment.EdgeBill)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgePaytype:
		return m.clearedpaytype
	case payment.EdgePaymentstatus:
		return m.clearedpaymentstatus
	case payment.EdgeBill:
		return m.clearedbill
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgePaytype:
		m.ClearPaytype()
		return nil
	case payment.EdgePaymentstatus:
		m.ClearPaymentstatus()
		return nil
	case payment.EdgeBill:
		m.ClearBill()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgePaytype:
		m.ResetPaytype()
		return nil
	case payment.EdgePaymentstatus:
		m.ResetPaymentstatus()
		return nil
	case payment.EdgeBill:
		m.ResetBill()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentStatusMutation represents an operation that mutate the PaymentStatusSlice
// nodes in the graph.
type PaymentStatusMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_PaymentStatus  *string
	clearedFields   map[string]struct{}
	payments        map[int]struct{}
	removedpayments map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*PaymentStatus, error)
}

var _ ent.Mutation = (*PaymentStatusMutation)(nil)

// paymentstatusOption allows to manage the mutation configuration using functional options.
type paymentstatusOption func(*PaymentStatusMutation)

// newPaymentStatusMutation creates new mutation for $n.Name.
func newPaymentStatusMutation(c config, op Op, opts ...paymentstatusOption) *PaymentStatusMutation {
	m := &PaymentStatusMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentStatusID sets the id field of the mutation.
func withPaymentStatusID(id int) paymentstatusOption {
	return func(m *PaymentStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentStatus
		)
		m.oldValue = func(ctx context.Context) (*PaymentStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentStatus sets the old PaymentStatus of the mutation.
func withPaymentStatus(node *PaymentStatus) paymentstatusOption {
	return func(m *PaymentStatusMutation) {
		m.oldValue = func(context.Context) (*PaymentStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPaymentStatus sets the PaymentStatus field.
func (m *PaymentStatusMutation) SetPaymentStatus(s string) {
	m._PaymentStatus = &s
}

// PaymentStatus returns the PaymentStatus value in the mutation.
func (m *PaymentStatusMutation) PaymentStatus() (r string, exists bool) {
	v := m._PaymentStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old PaymentStatus value of the PaymentStatus.
// If the PaymentStatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentStatusMutation) OldPaymentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus reset all changes of the "PaymentStatus" field.
func (m *PaymentStatusMutation) ResetPaymentStatus() {
	m._PaymentStatus = nil
}

// AddPaymentIDs adds the payments edge to Payment by ids.
func (m *PaymentStatusMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payments edge to Payment by ids.
func (m *PaymentStatusMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed ids of payments.
func (m *PaymentStatusMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the payments ids in the mutation.
func (m *PaymentStatusMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments reset all changes of the "payments" edge.
func (m *PaymentStatusMutation) ResetPayments() {
	m.payments = nil
	m.removedpayments = nil
}

// Op returns the operation name.
func (m *PaymentStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PaymentStatus).
func (m *PaymentStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentStatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PaymentStatus != nil {
		fields = append(fields, paymentstatus.FieldPaymentStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentstatus.FieldPaymentStatus:
		return m.PaymentStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentstatus.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentStatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentstatus.FieldPaymentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentStatusMutation) ResetField(name string) error {
	switch name {
	case paymentstatus.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	}
	return fmt.Errorf("unknown PaymentStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payments != nil {
		edges = append(edges, paymentstatus.EdgePayments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentstatus.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayments != nil {
		edges = append(edges, paymentstatus.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymentstatus.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentStatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentStatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentStatusMutation) ResetEdge(name string) error {
	switch name {
	case paymentstatus.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown PaymentStatus edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Email        *string
	clearedFields map[string]struct{}
	bills         map[int]struct{}
	removedbills  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetEmail sets the Email field.
func (m *UserMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the Email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old Email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "Email" field.
func (m *UserMutation) ResetEmail() {
	m._Email = nil
}

// AddBillIDs adds the bills edge to Bill by ids.
func (m *UserMutation) AddBillIDs(ids ...int) {
	if m.bills == nil {
		m.bills = make(map[int]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bills edge to Bill by ids.
func (m *UserMutation) RemoveBillIDs(ids ...int) {
	if m.removedbills == nil {
		m.removedbills = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed ids of bills.
func (m *UserMutation) RemovedBillsIDs() (ids []int) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the bills ids in the mutation.
func (m *UserMutation) BillsIDs() (ids []int) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills reset all changes of the "bills" edge.
func (m *UserMutation) ResetBills() {
	m.bills = nil
	m.removedbills = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._Email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bills != nil {
		edges = append(edges, user.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbills != nil {
		edges = append(edges, user.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
